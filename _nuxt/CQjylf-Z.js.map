{"version":3,"file":"CQjylf-Z.js","sources":["../../../../node_modules/nuxt/dist/app/composables/fetch.js","../../../../composables/useApi.ts","../../../../store/user.js","../../../../global/components/views/SimpleUserProfilePicture.vue"],"sourcesContent":["import { computed, reactive, toValue } from \"vue\";\nimport { hash } from \"ohash\";\nimport { useRequestFetch } from \"./ssr.js\";\nimport { useAsyncData } from \"./asyncData.js\";\nimport { fetchDefaults } from \"#build/nuxt.config.mjs\";\nexport function useFetch(request, arg1, arg2) {\n  const [opts = {}, autoKey] = typeof arg1 === \"string\" ? [{}, arg1] : [arg1, arg2];\n  const _request = computed(() => toValue(request));\n  const _key = opts.key || hash([autoKey, typeof _request.value === \"string\" ? _request.value : \"\", ...generateOptionSegments(opts)]);\n  if (!_key || typeof _key !== \"string\") {\n    throw new TypeError(\"[nuxt] [useFetch] key must be a string: \" + _key);\n  }\n  if (!request) {\n    throw new Error(\"[nuxt] [useFetch] request is missing.\");\n  }\n  const key = _key === autoKey ? \"$f\" + _key : _key;\n  if (!opts.baseURL && typeof _request.value === \"string\" && (_request.value[0] === \"/\" && _request.value[1] === \"/\")) {\n    throw new Error('[nuxt] [useFetch] the request URL must not start with \"//\".');\n  }\n  const {\n    server,\n    lazy,\n    default: defaultFn,\n    transform,\n    pick,\n    watch,\n    immediate,\n    getCachedData,\n    deep,\n    dedupe,\n    ...fetchOptions\n  } = opts;\n  const _fetchOptions = reactive({\n    ...fetchDefaults,\n    ...fetchOptions,\n    cache: typeof opts.cache === \"boolean\" ? void 0 : opts.cache\n  });\n  const _asyncDataOptions = {\n    server,\n    lazy,\n    default: defaultFn,\n    transform,\n    pick,\n    immediate,\n    getCachedData,\n    deep,\n    dedupe,\n    watch: watch === false ? [] : [_fetchOptions, _request, ...watch || []]\n  };\n  if (import.meta.dev && import.meta.client) {\n    _asyncDataOptions._functionName = opts._functionName || \"useFetch\";\n  }\n  let controller;\n  const asyncData = useAsyncData(key, () => {\n    controller?.abort?.();\n    controller = typeof AbortController !== \"undefined\" ? new AbortController() : {};\n    const timeoutLength = toValue(opts.timeout);\n    if (timeoutLength) {\n      setTimeout(() => controller.abort(), timeoutLength);\n    }\n    let _$fetch = opts.$fetch || globalThis.$fetch;\n    if (import.meta.server && !opts.$fetch) {\n      const isLocalFetch = typeof _request.value === \"string\" && _request.value[0] === \"/\" && (!toValue(opts.baseURL) || toValue(opts.baseURL)[0] === \"/\");\n      if (isLocalFetch) {\n        _$fetch = useRequestFetch();\n      }\n    }\n    return _$fetch(_request.value, { signal: controller.signal, ..._fetchOptions });\n  }, _asyncDataOptions);\n  return asyncData;\n}\nexport function useLazyFetch(request, arg1, arg2) {\n  const [opts = {}, autoKey] = typeof arg1 === \"string\" ? [{}, arg1] : [arg1, arg2];\n  if (import.meta.dev && import.meta.client) {\n    opts._functionName ||= \"useLazyFetch\";\n  }\n  return useFetch(\n    request,\n    {\n      ...opts,\n      lazy: true\n    },\n    // @ts-expect-error we pass an extra argument with the resolved auto-key to prevent another from being injected\n    autoKey\n  );\n}\nfunction generateOptionSegments(opts) {\n  const segments = [\n    toValue(opts.method)?.toUpperCase() || \"GET\",\n    toValue(opts.baseURL)\n  ];\n  for (const _obj of [opts.params || opts.query]) {\n    const obj = toValue(_obj);\n    if (!obj) {\n      continue;\n    }\n    const unwrapped = {};\n    for (const [key, value] of Object.entries(obj)) {\n      unwrapped[toValue(key)] = toValue(value);\n    }\n    segments.push(unwrapped);\n  }\n  return segments;\n}\n","import type { UseFetchOptions } from \"nuxt/app\";\nimport { defu } from \"defu\";\n\nexport async function useApi<T>(url: string | (() => string), options: UseFetchOptions<T> = {}) {\n  // const userAuth = useCookie(\"token\");\n  const { getSession } = useAuth();\n  const config = useRuntimeConfig();\n  const session = await getSession();\n\n  const defaults: UseFetchOptions<T> = {\n    method: \"GET\",\n    baseURL: config.public.apiUrl ?? \"http://localhost:8090\",\n    // this overrides the default key generation, which includes a hash of\n    // url, method, headers, etc. - this should be used with care as the key\n    // is how Nuxt decides how responses should be deduplicated between\n    // client and server\n    // key: url,\n\n    // set user token if connected\n    headers: {\n      Authorization: `Bearer ${session?.token?.access_token}`\n    },\n    lazy: true,\n    server: false\n\n    // onResponse(_ctx) {\n    //   // _ctx.response._data = new myBusinessResponse(_ctx.response._data)\n    // },\n\n    // onResponseError(_ctx) {\n    //   // throw new myBusinessError()\n    // }\n  };\n\n  // for nice deep defaults, please use unjs/defu\n  const params = defu(options, defaults);\n\n  return useFetch<T>(url, params);\n}\n","import { defineStore } from \"pinia\";\nconst config = useRuntimeConfig();\n\nexport const useUserStore = defineStore(\"user\", {\n  actions: {\n    async LOAD_PROFILE_PICTURE_BLOB(blob) {\n      if (this.profilePicture) {\n        await new Promise(resolve => {\n          try {\n            URL.revokeObjectURL(this.profilePicture);\n          } catch (e) {\n          } finally {\n            resolve();\n          }\n        });\n\n        await new Promise(resolve => {\n          this.profilePicture = null;\n\n          resolve();\n        });\n      }\n\n      this.profilePicture = URL.createObjectURL(blob);\n    },\n    async FETCH_PROFILE_PICTURE() {\n      this.loadingProfilePicture = true;\n      // Load Auth Data\n      const { getSession } = useAuth();\n      const session = await getSession();\n      // If the data contains a link to a profile picture\n      if (session?.session?.user?.image) {\n        // We use the `useApi` composable (ignoring the stupid Nuxt warning about the component already being mounted)\n        useFetch(session.session.user.image, {\n          responseType: \"blob\",\n          baseURL: config.public.apiUrl ?? \"http://localhost:8090\",\n          // this overrides the default key generation, which includes a hash of\n          // url, method, headers, etc. - this should be used with care as the key\n          // is how Nuxt decides how responses should be deduplicated between\n          // client and server\n          key: \"user-profile-picture\",\n          server: true,\n          lazy: false,\n\n          // set user token if connected\n          headers: {\n            Authorization: `Bearer ${session?.token?.access_token}`\n          }\n        })\n          .then(res => {\n            // We take the response which is a blob and load it into the image tags 'src' attribute using an Object URL\n            this.LOAD_PROFILE_PICTURE_BLOB(res.data.value);\n          })\n          .catch(ignored => {\n            console.error(\"There was a problem loading the profile picture. %o\", ignored);\n          })\n          .finally(() => {\n            this.loadingProfilePicture = false;\n          });\n      }\n    },\n    async UPDATE_PROFILE_PICTURE(file) {\n      const { signIn } = useAuth();\n      this.loadingProfilePicture = true;\n\n      if (!file) return;\n\n      try {\n        console.log(\"We have a file: %o\", file);\n\n        // Load Auth Data\n\n        await new Promise(resolve => setTimeout(resolve, 1000));\n\n        const formData = new FormData();\n\n        formData.append(\"image\", file);\n\n        // this.setUploading(true);\n\n        useApi(`/user/profile/picture`, {\n          method: \"post\",\n          body: formData\n          // query: _getQuery(),\n          // transform: jobParser\n        })\n          .then(res => {\n            console.log(\"Pinia Response: %o\", res);\n          })\n          .catch(e => {\n            console.log(\"Pinia Error: %o\", e);\n          })\n          .finally(() => {\n            this.loadingProfilePicture = false;\n\n            // const route = useRoute();\n\n            // console.log(\"Route: %o\", Object.keys(route));\n\n            // signIn(\"oidc\", { callbackUrl: false });\n\n            // const router = useRouter();\n            // router.push(route);\n          });\n      } catch (e) {\n      } finally {\n      }\n      // if (file) {\n      //   this.profilePicture = file;\n      // }\n      // // If the data contains a link to a profile picture\n      // if (session?.session?.user?.image) {\n      //   // We use the `useApi` composable (ignoring the stupid Nuxt warning about the component already being mounted)\n      //   useApi(session.session.user.image, { responseType: \"blob\" })\n      //     .then(res => {\n      //       // We take the response which is a blob and load it into the image tags 'src' attribute using an Object URL\n      //       this.LOAD_PROFILE_PICTURE_BLOB(res.data.value);\n      //     })\n      //     .catch(ignored => {\n      //       console.error(\"There was a problem loading the profile picture. %o\", ignored);\n      //     })\n      //     .finally(() => {\n      //       this.loadingProfilePicture = false;\n      //     });\n      // }\n    }\n  },\n  getters: {\n    shouldRememberUser(state) {\n      return state.rememberMe;\n    }\n  },\n  state: () => ({\n    loadingProfilePicture: true,\n    profilePicture: null,\n    rememberMe: false\n  })\n});\n","<template>\n  <div\n    class=\"position-relative\"\n    :style=\"{\n      height: !Number.isNaN(props.size) ? props.size : props.size + 'px',\n      width: !Number.isNaN(props.size) ? props.size : props.size + 'px',\n      margin: `.15rem 0 .15rem ${((props.elevation || 1) * 2) / 10}rem`\n    }\"\n  >\n    <img\n      ref=\"image\"\n      :alt=\"$t('GENERAL.LABEL.USER_AVATAR')\"\n      :class=\"['img-circle', `elevation-${elevation}`, 'm-0']\"\n      :src=\"store.profilePicture || '/images/user-placeholder.png'\"\n      style=\"object-fit: cover; height: 100%; width: 100%\"\n    />\n    <div\n      v-if=\"store.loadingProfilePicture\"\n      class=\"position-absolute d-flex align-items-center justify-content-around text-success rounded-circle\"\n      :style=\"{ top: 0, left: 0, width: '100%', height: '100%', 'background-color': overlayColor }\"\n    >\n      <fa-icon icon=\"spinner\" :class=\"iconClasses\" />\n    </div>\n  </div>\n</template>\n>\n\n<script setup>\n  import { useUserStore } from \"@/store/user\";\n  const store = useUserStore();\n  import AllowedIconSizes from \"~/constants/AllowedIconSizes\";\n\n  const props = defineProps({\n    elevation: {\n      type: [String, Number],\n      requireD: false,\n      default() {\n        return 2;\n      }\n    },\n    iconSize: {\n      type: String,\n      default() {\n        return \"lg\";\n      },\n      validator(iconSize) {\n        return AllowedIconSizes.includes(iconSize);\n      }\n    },\n    overlayIconClasses: {\n      default() {\n        return null;\n      }\n    },\n    overlayColor: {\n      type: String,\n      required: false,\n      default() {\n        return \"rgba(0, 0, 0, 0.8)\";\n      }\n    },\n    size: {\n      type: [String, Number],\n      requireD: false,\n      default() {\n        return \"2.1rem\";\n      }\n    },\n    animationMode: {\n      type: String,\n      default() {\n        return \"spin\";\n      },\n      validator(animationMode) {\n        return [\"pulse\", \"spin\"].includes(animationMode);\n      }\n    }\n  });\n\n  const iconClasses = computed(() => {\n    const classes = [`fa-${props.animationMode}`, `fa-${props.iconSize}`];\n\n    if (props.overlayIconClasses) classes.push(props.overlayIconClasses);\n\n    return classes;\n  });\n\n  store.FETCH_PROFILE_PICTURE();\n\n  onMounted(() => {\n    console.log(\"Is Mounted\");\n  });\n</script>\n"],"names":["useFetch","request","arg1","arg2","opts","autoKey","_request","computed","toValue","_key","hash","generateOptionSegments","key","server","lazy","defaultFn","transform","pick","watch","immediate","getCachedData","deep","dedupe","fetchOptions","_fetchOptions","reactive","fetchDefaults","_asyncDataOptions","controller","useAsyncData","_a","timeoutLength","segments","_obj","obj","unwrapped","value","useApi","url","options","getSession","config","useRuntimeConfig","session","defaults","params","defu","useUserStore","defineStore","blob","resolve","_b","_c","res","ignored","file","formData","e","state","store","props","__props","iconClasses","classes","onMounted"],"mappings":"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","x_google_ignoreList":[0]}