{"version":3,"mappings":"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","names":["isDefer","dedupe","useAsyncData","args","autoKey","key","_handler","options","nuxtApp","useNuxtApp","handler","getDefault","getDefaultCachedData","asyncDataDefaults","hasCachedData","_a","_ref","ref","shallowRef","toRef","asyncData","opts","promise","resolve","reject","err","_result","result","pick","error","createError","unref","clearNuxtDataByKey","initialFetch","fetchOnServer","instance","getCurrentInstance","cbs","onBeforeMount","cb","onUnmounted","hasScope","getCurrentScope","unsub","watch","onScopeDispose","off","keys","asyncDataPromise","useLazyAsyncData","obj","newObj","get","path","acc","part","_pick","condition","omit","apply","fn","data","item","detectProperties","prefixes","properties","withoutKeys","withKeys","sortList","params","comperable","a","b","values","value","assertArray","message","ensureArray","arrayParams","createQuery","fetcher","queryParams","$set","v","query","resolveResult","q","sort","_locale","surroundQuery","jsonStringify","regExpReplacer","_key","encodeQueryParams","encoded","createQueryFetch","content","useRuntimeConfig","apiPath","withContentBase","hash","shouldUseClientDB","m","useContentPreview","queryContent","pathParts","queryBuilder","withLeadingSlash","joinURL","originalParamsFn","withoutTrailingSlash","_c","_b","w"],"ignoreList":[0,1,2,3,4,5],"sources":["../../../../node_modules/nuxt/dist/app/composables/asyncData.js","../../../../node_modules/@nuxt/content/dist/runtime/query/match/utils.js","../../../../node_modules/@nuxt/content/dist/runtime/query/query.js","../../../../node_modules/@nuxt/content/dist/runtime/utils/json.js","../../../../node_modules/@nuxt/content/dist/runtime/utils/query.js","../../../../node_modules/@nuxt/content/dist/runtime/legacy/composables/query.js"],"sourcesContent":["import { computed, getCurrentInstance, getCurrentScope, onBeforeMount, onScopeDispose, onServerPrefetch, onUnmounted, ref, shallowRef, toRef, unref, watch } from \"vue\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { toArray } from \"../utils.js\";\nimport { createError } from \"./error.js\";\nimport { onNuxtReady } from \"./ready.js\";\nimport { asyncDataDefaults } from \"#build/nuxt.config.mjs\";\nconst isDefer = (dedupe) => dedupe === \"defer\" || dedupe === false;\nexport function useAsyncData(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (typeof args[0] !== \"string\") {\n    args.unshift(autoKey);\n  }\n  let [key, _handler, options = {}] = args;\n  if (typeof key !== \"string\") {\n    throw new TypeError(\"[nuxt] [asyncData] key must be a string.\");\n  }\n  if (typeof _handler !== \"function\") {\n    throw new TypeError(\"[nuxt] [asyncData] handler must be a function.\");\n  }\n  const nuxtApp = useNuxtApp();\n  const handler = import.meta.client || !import.meta.prerender || !nuxtApp.ssrContext?._sharedPrerenderCache ? _handler : () => {\n    const value = nuxtApp.ssrContext._sharedPrerenderCache.get(key);\n    if (value) {\n      return value;\n    }\n    const promise = nuxtApp.runWithContext(_handler);\n    nuxtApp.ssrContext._sharedPrerenderCache.set(key, promise);\n    return promise;\n  };\n  const getDefault = () => null;\n  const getDefaultCachedData = () => nuxtApp.isHydrating ? nuxtApp.payload.data[key] : nuxtApp.static.data[key];\n  options.server = options.server ?? true;\n  options.default = options.default ?? getDefault;\n  options.getCachedData = options.getCachedData ?? getDefaultCachedData;\n  options.lazy = options.lazy ?? false;\n  options.immediate = options.immediate ?? true;\n  options.deep = options.deep ?? asyncDataDefaults.deep;\n  options.dedupe = options.dedupe ?? \"cancel\";\n  if (import.meta.dev && typeof options.dedupe === \"boolean\") {\n    console.warn(\"[nuxt] `boolean` values are deprecated for the `dedupe` option of `useAsyncData` and will be removed in the future. Use 'cancel' or 'defer' instead.\");\n  }\n  const hasCachedData = () => options.getCachedData(key, nuxtApp) != null;\n  if (!nuxtApp._asyncData[key] || !options.immediate) {\n    nuxtApp.payload._errors[key] ??= null;\n    const _ref = options.deep ? ref : shallowRef;\n    nuxtApp._asyncData[key] = {\n      data: _ref(options.getCachedData(key, nuxtApp) ?? options.default()),\n      pending: ref(!hasCachedData()),\n      error: toRef(nuxtApp.payload._errors, key),\n      status: ref(\"idle\")\n    };\n  }\n  const asyncData = { ...nuxtApp._asyncData[key] };\n  asyncData.refresh = asyncData.execute = (opts = {}) => {\n    if (nuxtApp._asyncDataPromises[key]) {\n      if (isDefer(opts.dedupe ?? options.dedupe)) {\n        return nuxtApp._asyncDataPromises[key];\n      }\n      nuxtApp._asyncDataPromises[key].cancelled = true;\n    }\n    if ((opts._initial || nuxtApp.isHydrating && opts._initial !== false) && hasCachedData()) {\n      return Promise.resolve(options.getCachedData(key, nuxtApp));\n    }\n    asyncData.pending.value = true;\n    asyncData.status.value = \"pending\";\n    const promise = new Promise(\n      (resolve, reject) => {\n        try {\n          resolve(handler(nuxtApp));\n        } catch (err) {\n          reject(err);\n        }\n      }\n    ).then(async (_result) => {\n      if (promise.cancelled) {\n        return nuxtApp._asyncDataPromises[key];\n      }\n      let result = _result;\n      if (options.transform) {\n        result = await options.transform(_result);\n      }\n      if (options.pick) {\n        result = pick(result, options.pick);\n      }\n      nuxtApp.payload.data[key] = result;\n      asyncData.data.value = result;\n      asyncData.error.value = null;\n      asyncData.status.value = \"success\";\n    }).catch((error) => {\n      if (promise.cancelled) {\n        return nuxtApp._asyncDataPromises[key];\n      }\n      asyncData.error.value = createError(error);\n      asyncData.data.value = unref(options.default());\n      asyncData.status.value = \"error\";\n    }).finally(() => {\n      if (promise.cancelled) {\n        return;\n      }\n      asyncData.pending.value = false;\n      delete nuxtApp._asyncDataPromises[key];\n    });\n    nuxtApp._asyncDataPromises[key] = promise;\n    return nuxtApp._asyncDataPromises[key];\n  };\n  asyncData.clear = () => clearNuxtDataByKey(nuxtApp, key);\n  const initialFetch = () => asyncData.refresh({ _initial: true });\n  const fetchOnServer = options.server !== false && nuxtApp.payload.serverRendered;\n  if (import.meta.server && fetchOnServer && options.immediate) {\n    const promise = initialFetch();\n    if (getCurrentInstance()) {\n      onServerPrefetch(() => promise);\n    } else {\n      nuxtApp.hook(\"app:created\", async () => {\n        await promise;\n      });\n    }\n  }\n  if (import.meta.client) {\n    const instance = getCurrentInstance();\n    if (import.meta.dev && !nuxtApp.isHydrating && (!instance || instance?.isMounted)) {\n      console.warn(`[nuxt] [${options._functionName || \"useAsyncData\"}] Component is already mounted, please use $fetch instead. See https://nuxt.com/docs/getting-started/data-fetching`);\n    }\n    if (instance && !instance._nuxtOnBeforeMountCbs) {\n      instance._nuxtOnBeforeMountCbs = [];\n      const cbs = instance._nuxtOnBeforeMountCbs;\n      onBeforeMount(() => {\n        cbs.forEach((cb) => {\n          cb();\n        });\n        cbs.splice(0, cbs.length);\n      });\n      onUnmounted(() => cbs.splice(0, cbs.length));\n    }\n    if (fetchOnServer && nuxtApp.isHydrating && (asyncData.error.value || hasCachedData())) {\n      asyncData.pending.value = false;\n      asyncData.status.value = asyncData.error.value ? \"error\" : \"success\";\n    } else if (instance && (nuxtApp.payload.serverRendered && nuxtApp.isHydrating || options.lazy) && options.immediate) {\n      instance._nuxtOnBeforeMountCbs.push(initialFetch);\n    } else if (options.immediate) {\n      initialFetch();\n    }\n    const hasScope = getCurrentScope();\n    if (options.watch) {\n      const unsub = watch(options.watch, () => asyncData.refresh());\n      if (hasScope) {\n        onScopeDispose(unsub);\n      }\n    }\n    const off = nuxtApp.hook(\"app:data:refresh\", async (keys) => {\n      if (!keys || keys.includes(key)) {\n        await asyncData.refresh();\n      }\n    });\n    if (hasScope) {\n      onScopeDispose(off);\n    }\n  }\n  const asyncDataPromise = Promise.resolve(nuxtApp._asyncDataPromises[key]).then(() => asyncData);\n  Object.assign(asyncDataPromise, asyncData);\n  return asyncDataPromise;\n}\nexport function useLazyAsyncData(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (typeof args[0] !== \"string\") {\n    args.unshift(autoKey);\n  }\n  const [key, handler, options = {}] = args;\n  if (import.meta.dev && import.meta.client) {\n    options._functionName ||= \"useLazyAsyncData\";\n  }\n  return useAsyncData(key, handler, { ...options, lazy: true }, null);\n}\nexport function useNuxtData(key) {\n  const nuxtApp = useNuxtApp();\n  if (!(key in nuxtApp.payload.data)) {\n    nuxtApp.payload.data[key] = null;\n  }\n  return {\n    data: computed({\n      get() {\n        return nuxtApp._asyncData[key]?.data.value ?? nuxtApp.payload.data[key];\n      },\n      set(value) {\n        if (nuxtApp._asyncData[key]) {\n          nuxtApp._asyncData[key].data.value = value;\n        } else {\n          nuxtApp.payload.data[key] = value;\n        }\n      }\n    })\n  };\n}\nexport async function refreshNuxtData(keys) {\n  if (import.meta.server) {\n    return Promise.resolve();\n  }\n  await new Promise((resolve) => onNuxtReady(resolve));\n  const _keys = keys ? toArray(keys) : void 0;\n  await useNuxtApp().hooks.callHookParallel(\"app:data:refresh\", _keys);\n}\nexport function clearNuxtData(keys) {\n  const nuxtApp = useNuxtApp();\n  const _allKeys = Object.keys(nuxtApp.payload.data);\n  const _keys = !keys ? _allKeys : typeof keys === \"function\" ? _allKeys.filter(keys) : toArray(keys);\n  for (const key of _keys) {\n    clearNuxtDataByKey(nuxtApp, key);\n  }\n}\nfunction clearNuxtDataByKey(nuxtApp, key) {\n  if (key in nuxtApp.payload.data) {\n    nuxtApp.payload.data[key] = void 0;\n  }\n  if (key in nuxtApp.payload._errors) {\n    nuxtApp.payload._errors[key] = null;\n  }\n  if (nuxtApp._asyncData[key]) {\n    nuxtApp._asyncData[key].data.value = void 0;\n    nuxtApp._asyncData[key].error.value = null;\n    nuxtApp._asyncData[key].pending.value = false;\n    nuxtApp._asyncData[key].status.value = \"idle\";\n  }\n  if (key in nuxtApp._asyncDataPromises) {\n    nuxtApp._asyncDataPromises[key].cancelled = true;\n    nuxtApp._asyncDataPromises[key] = void 0;\n  }\n}\nfunction pick(obj, keys) {\n  const newObj = {};\n  for (const key of keys) {\n    newObj[key] = obj[key];\n  }\n  return newObj;\n}\n","export const get = (obj, path) => path.split(\".\").reduce((acc, part) => acc && acc[part], obj);\nconst _pick = (obj, condition) => Object.keys(obj).filter(condition).reduce((newObj, key) => Object.assign(newObj, { [key]: obj[key] }), {});\nexport const pick = (keys) => (obj) => keys && keys.length ? _pick(obj, (key) => keys.includes(key)) : obj;\nexport const omit = (keys) => (obj) => keys && keys.length ? _pick(obj, (key) => !keys.includes(key)) : obj;\nexport const apply = (fn) => (data) => Array.isArray(data) ? data.map((item) => fn(item)) : fn(data);\nexport const detectProperties = (keys) => {\n  const prefixes = [];\n  const properties = [];\n  for (const key of keys) {\n    if ([\"$\", \"_\"].includes(key)) {\n      prefixes.push(key);\n    } else {\n      properties.push(key);\n    }\n  }\n  return { prefixes, properties };\n};\nexport const withoutKeys = (keys = []) => (obj) => {\n  if (keys.length === 0 || !obj) {\n    return obj;\n  }\n  const { prefixes, properties } = detectProperties(keys);\n  return _pick(obj, (key) => !properties.includes(key) && !prefixes.includes(key[0]));\n};\nexport const withKeys = (keys = []) => (obj) => {\n  if (keys.length === 0 || !obj) {\n    return obj;\n  }\n  const { prefixes, properties } = detectProperties(keys);\n  return _pick(obj, (key) => properties.includes(key) || prefixes.includes(key[0]));\n};\nexport const sortList = (data, params) => {\n  const comperable = new Intl.Collator(params.$locale, {\n    numeric: params.$numeric,\n    caseFirst: params.$caseFirst,\n    sensitivity: params.$sensitivity\n  });\n  const keys = Object.keys(params).filter((key) => !key.startsWith(\"$\"));\n  for (const key of keys) {\n    data = data.sort((a, b) => {\n      const values = [get(a, key), get(b, key)].map((value) => {\n        if (value === null) {\n          return void 0;\n        }\n        if (value instanceof Date) {\n          return value.toISOString();\n        }\n        return value;\n      });\n      if (params[key] === -1) {\n        values.reverse();\n      }\n      return comperable.compare(values[0], values[1]);\n    });\n  }\n  return data;\n};\nexport const assertArray = (value, message = \"Expected an array\") => {\n  if (!Array.isArray(value)) {\n    throw new TypeError(message);\n  }\n};\nexport const ensureArray = (value) => {\n  return Array.isArray(value) ? value : [void 0, null].includes(value) ? [] : [value];\n};\n","import { ensureArray } from \"./match/utils.js\";\nconst arrayParams = [\"sort\", \"where\", \"only\", \"without\"];\nexport function createQuery(fetcher, opts = {}) {\n  const queryParams = {};\n  for (const key of Object.keys(opts.initialParams || {})) {\n    queryParams[key] = arrayParams.includes(key) ? ensureArray(opts.initialParams[key]) : opts.initialParams[key];\n  }\n  const $set = (key, fn = (v) => v) => {\n    return (...values) => {\n      queryParams[key] = fn(...values);\n      return query;\n    };\n  };\n  const resolveResult = (result) => {\n    if (opts.legacy) {\n      if (result?.surround) {\n        return result.surround;\n      }\n      if (!result) {\n        return result;\n      }\n      if (result?.dirConfig) {\n        result.result = {\n          _path: result.dirConfig?._path,\n          ...result.result,\n          _dir: result.dirConfig\n        };\n      }\n      return result?._path || Array.isArray(result) || !Object.prototype.hasOwnProperty.call(result, \"result\") ? result : result?.result;\n    }\n    return result;\n  };\n  const query = {\n    params: () => ({\n      ...queryParams,\n      ...queryParams.where ? { where: [...ensureArray(queryParams.where)] } : {},\n      ...queryParams.sort ? { sort: [...ensureArray(queryParams.sort)] } : {}\n    }),\n    only: $set(\"only\", ensureArray),\n    without: $set(\"without\", ensureArray),\n    where: $set(\"where\", (q) => [...ensureArray(queryParams.where), ...ensureArray(q)]),\n    sort: $set(\"sort\", (sort) => [...ensureArray(queryParams.sort), ...ensureArray(sort)]),\n    limit: $set(\"limit\", (v) => parseInt(String(v), 10)),\n    skip: $set(\"skip\", (v) => parseInt(String(v), 10)),\n    // find\n    find: () => fetcher(query).then(resolveResult),\n    findOne: () => fetcher($set(\"first\")(true)).then(resolveResult),\n    count: () => fetcher($set(\"count\")(true)).then(resolveResult),\n    // locale\n    locale: (_locale) => query.where({ _locale }),\n    withSurround: $set(\"surround\", (surroundQuery, options) => ({ query: surroundQuery, ...options })),\n    withDirConfig: () => $set(\"dirConfig\")(true)\n  };\n  if (opts.legacy) {\n    query.findSurround = (surroundQuery, options) => {\n      return query.withSurround(surroundQuery, options).find().then(resolveResult);\n    };\n    return query;\n  }\n  return query;\n}\n","export function jsonStringify(value) {\n  return JSON.stringify(value, regExpReplacer);\n}\nexport function jsonParse(value) {\n  return JSON.parse(value, regExpReviver);\n}\nfunction regExpReplacer(_key, value) {\n  if (value instanceof RegExp) {\n    return `--REGEX ${value.toString()}`;\n  }\n  return value;\n}\nfunction regExpReviver(_key, value) {\n  const withOperator = typeof value === \"string\" && value.match(/^--([A-Z]+) (.+)$/) || [];\n  if (withOperator[1] === \"REGEX\") {\n    const regex = withOperator[2].match(/\\/(.*)\\/([dgimsuy]*)$/);\n    return regex ? new RegExp(regex[1], regex[2] || \"\") : value;\n  }\n  return value;\n}\n","import { getQuery, createError } from \"h3\";\nimport { jsonParse, jsonStringify } from \"./json.js\";\nconst parseJSONQueryParams = (body) => {\n  try {\n    return jsonParse(body);\n  } catch (e) {\n    throw createError({ statusCode: 400, message: \"Invalid _params query\" });\n  }\n};\nexport const encodeQueryParams = (params) => {\n  let encoded = jsonStringify(params);\n  encoded = typeof Buffer !== \"undefined\" ? Buffer.from(encoded).toString(\"base64\") : btoa(encoded);\n  encoded = encoded.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \"\");\n  const chunks = encoded.match(/.{1,100}/g) || [];\n  return chunks.join(\"/\");\n};\nexport const decodeQueryParams = (encoded) => {\n  encoded = encoded.replace(/\\//g, \"\");\n  encoded = encoded.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  encoded = encoded.padEnd(encoded.length + (4 - encoded.length % 4) % 4, \"=\");\n  return parseJSONQueryParams(typeof Buffer !== \"undefined\" ? Buffer.from(encoded, \"base64\").toString() : atob(encoded));\n};\nconst memory = {};\nexport const getContentQuery = (event) => {\n  const { params } = event.context.params || {};\n  if (params) {\n    return decodeQueryParams(params.replace(/.json$/, \"\"));\n  }\n  const qid = event.context.params?.qid?.replace(/.json$/, \"\");\n  const query = getQuery(event) || {};\n  if (qid && query._params) {\n    memory[qid] = parseJSONQueryParams(decodeURIComponent(query._params));\n    if (memory[qid].where && !Array.isArray(memory[qid].where)) {\n      memory[qid].where = [memory[qid].where];\n    }\n    return memory[qid];\n  }\n  if (qid && memory[qid]) {\n    return memory[qid];\n  }\n  if (query._params) {\n    return parseJSONQueryParams(decodeURIComponent(query._params));\n  }\n  if (typeof query.only === \"string\" && query.only.includes(\",\")) {\n    query.only = query.only.split(\",\").map((s) => s.trim());\n  }\n  if (typeof query.without === \"string\" && query.without.includes(\",\")) {\n    query.without = query.without.split(\",\").map((s) => s.trim());\n  }\n  const where = query.where || {};\n  for (const key of [\"draft\", \"partial\", \"empty\"]) {\n    if (query[key] && [\"true\", \"false\"].includes(query[key])) {\n      where[key] = query[key] === \"true\";\n      delete query[key];\n    }\n  }\n  if (query.sort) {\n    query.sort = String(query.sort).split(\",\").map((s) => {\n      const [key, order] = s.split(\":\");\n      return [key, +order];\n    });\n  }\n  const reservedKeys = [\"partial\", \"draft\", \"only\", \"without\", \"where\", \"sort\", \"limit\", \"skip\"];\n  for (const key of Object.keys(query)) {\n    if (reservedKeys.includes(key)) {\n      continue;\n    }\n    query.where = query.where || {};\n    query.where[key] = query[key];\n  }\n  if (Object.keys(where).length > 0) {\n    query.where = [where];\n  } else {\n    delete query.where;\n  }\n  return query;\n};\n","import { joinURL, withLeadingSlash, withoutTrailingSlash } from \"ufo\";\nimport { hash } from \"ohash\";\nimport { createQuery } from \"../../query/query.js\";\nimport { encodeQueryParams } from \"../../utils/query.js\";\nimport { jsonStringify } from \"../../utils/json.js\";\nimport { addPrerenderPath, shouldUseClientDB, withContentBase } from \"../../composables/utils.js\";\nimport { useContentPreview } from \"../../composables/preview.js\";\nimport { useRuntimeConfig } from \"#imports\";\nexport const createQueryFetch = () => async (query) => {\n  const { content } = useRuntimeConfig().public;\n  const params = query.params();\n  const apiPath = content.experimental.stripQueryParameters ? withContentBase(`/query/${process.dev ? \"_\" : `${hash(params)}.${content.integrity}`}/${encodeQueryParams(params)}.json`) : withContentBase(process.dev ? \"/query\" : `/query/${hash(params)}.${content.integrity}.json`);\n  if (!process.dev && process.server) {\n    addPrerenderPath(apiPath);\n  }\n  if (shouldUseClientDB()) {\n    const db = await import(\"./client-db.js\").then((m) => m.useContentDatabase());\n    return db.fetch(query);\n  }\n  const data = await $fetch(apiPath, {\n    method: \"GET\",\n    responseType: \"json\",\n    params: content.experimental.stripQueryParameters ? void 0 : {\n      _params: jsonStringify(params),\n      previewToken: useContentPreview().getPreviewToken()\n    }\n  });\n  if (typeof data === \"string\" && data.startsWith(\"<!DOCTYPE html>\")) {\n    throw new Error(\"Not found\");\n  }\n  return data;\n};\nexport function queryContent(query, ...pathParts) {\n  const { content } = useRuntimeConfig().public;\n  const queryBuilder = createQuery(createQueryFetch(), {\n    initialParams: typeof query !== \"string\" ? query : {},\n    legacy: true\n  });\n  let path;\n  if (typeof query === \"string\") {\n    path = withLeadingSlash(joinURL(query, ...pathParts));\n  }\n  const originalParamsFn = queryBuilder.params;\n  queryBuilder.params = () => {\n    const params = originalParamsFn();\n    if (path) {\n      params.where = params.where || [];\n      if (params.first && (params.where || []).length === 0) {\n        params.where.push({ _path: withoutTrailingSlash(path) });\n      } else {\n        params.where.push({ _path: new RegExp(`^${path.replace(/[-[\\]{}()*+.,^$\\s/]/g, \"\\\\$&\")}`) });\n      }\n    }\n    if (!params.sort?.length) {\n      params.sort = [{ _file: 1, $numeric: true }];\n    }\n    if (content.locales.length) {\n      const queryLocale = params.where?.find((w) => w._locale)?._locale;\n      if (!queryLocale) {\n        params.where = params.where || [];\n        params.where.push({ _locale: content.defaultLocale });\n      }\n    }\n    return params;\n  };\n  return queryBuilder;\n}\n"],"file":"_nuxt/C_-XZwgH.js"}